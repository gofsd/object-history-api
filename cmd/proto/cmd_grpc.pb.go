// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.6
// source: proto/cmd/cmd.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CommandService_ListGroups_FullMethodName             = "/cmd.CommandService/ListGroups"
	CommandService_AddGroup_FullMethodName               = "/cmd.CommandService/AddGroup"
	CommandService_DeleteGroup_FullMethodName            = "/cmd.CommandService/DeleteGroup"
	CommandService_AddUserToGroup_FullMethodName         = "/cmd.CommandService/AddUserToGroup"
	CommandService_RemoveUserFromGroup_FullMethodName    = "/cmd.CommandService/RemoveUserFromGroup"
	CommandService_ListCommands_FullMethodName           = "/cmd.CommandService/ListCommands"
	CommandService_AddCommand_FullMethodName             = "/cmd.CommandService/AddCommand"
	CommandService_DeleteCommand_FullMethodName          = "/cmd.CommandService/DeleteCommand"
	CommandService_AddCommandToGroup_FullMethodName      = "/cmd.CommandService/AddCommandToGroup"
	CommandService_DeleteCommandFromGroup_FullMethodName = "/cmd.CommandService/DeleteCommandFromGroup"
	CommandService_ListExecutions_FullMethodName         = "/cmd.CommandService/ListExecutions"
	CommandService_Execute_FullMethodName                = "/cmd.CommandService/Execute"
	CommandService_Cancel_FullMethodName                 = "/cmd.CommandService/Cancel"
	CommandService_Retry_FullMethodName                  = "/cmd.CommandService/Retry"
	CommandService_DryRun_FullMethodName                 = "/cmd.CommandService/DryRun"
	CommandService_UpdateExecutionStatus_FullMethodName  = "/cmd.CommandService/UpdateExecutionStatus"
	CommandService_SubscribeLogs_FullMethodName          = "/cmd.CommandService/SubscribeLogs"
	CommandService_SubscribeCommandEvents_FullMethodName = "/cmd.CommandService/SubscribeCommandEvents"
	CommandService_AddMutualContact_FullMethodName       = "/cmd.CommandService/AddMutualContact"
	CommandService_RemoveMutualContact_FullMethodName    = "/cmd.CommandService/RemoveMutualContact"
	CommandService_ShowMyContact_FullMethodName          = "/cmd.CommandService/ShowMyContact"
)

// CommandServiceClient is the client API for CommandService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// CommandService provides all command and group management operations.
type CommandServiceClient interface {
	// Group management
	ListGroups(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GroupsResponse, error)
	AddGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Group, error)
	DeleteGroup(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*Group, error)
	AddUserToGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error)
	RemoveUserFromGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error)
	// Template management
	ListCommands(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandsResponse, error)
	AddCommand(ctx context.Context, in *AddCommandRequest, opts ...grpc.CallOption) (*Command, error)
	DeleteCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*Command, error)
	AddCommandToGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error)
	DeleteCommandFromGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error)
	// Execution
	ListExecutions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CommandLog], error)
	Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error)
	Cancel(ctx context.Context, in *CancelRequest, opts ...grpc.CallOption) (*CancelResponse, error)
	Retry(ctx context.Context, in *RetryRequest, opts ...grpc.CallOption) (*ExecuteResponse, error)
	DryRun(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*DryRunResult, error)
	// Update execution status
	UpdateExecutionStatus(ctx context.Context, in *UpdateExecutionStatusRequest, opts ...grpc.CallOption) (*UpdateExecutionStatusResponse, error)
	// Streaming logs
	SubscribeLogs(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SubscribeRequest, CommandLog], error)
	// Event listener for executors
	SubscribeCommandEvents(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[CommandLog, CommandEvent], error)
	// Add a contact for a user.
	AddMutualContact(ctx context.Context, in *Contact, opts ...grpc.CallOption) (*Contact, error)
	RemoveMutualContact(ctx context.Context, in *Contact, opts ...grpc.CallOption) (*Contact, error)
	ShowMyContact(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Contact, error)
}

type commandServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommandServiceClient(cc grpc.ClientConnInterface) CommandServiceClient {
	return &commandServiceClient{cc}
}

func (c *commandServiceClient) ListGroups(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GroupsResponse)
	err := c.cc.Invoke(ctx, CommandService_ListGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) AddGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Group, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Group)
	err := c.cc.Invoke(ctx, CommandService_AddGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) DeleteGroup(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*Group, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Group)
	err := c.cc.Invoke(ctx, CommandService_DeleteGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) AddUserToGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserGroupResponse)
	err := c.cc.Invoke(ctx, CommandService_AddUserToGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) RemoveUserFromGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserGroupResponse)
	err := c.cc.Invoke(ctx, CommandService_RemoveUserFromGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) ListCommands(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandsResponse)
	err := c.cc.Invoke(ctx, CommandService_ListCommands_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) AddCommand(ctx context.Context, in *AddCommandRequest, opts ...grpc.CallOption) (*Command, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Command)
	err := c.cc.Invoke(ctx, CommandService_AddCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) DeleteCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*Command, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Command)
	err := c.cc.Invoke(ctx, CommandService_DeleteCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) AddCommandToGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserGroupResponse)
	err := c.cc.Invoke(ctx, CommandService_AddCommandToGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) DeleteCommandFromGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserGroupResponse)
	err := c.cc.Invoke(ctx, CommandService_DeleteCommandFromGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) ListExecutions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CommandLog], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CommandService_ServiceDesc.Streams[0], CommandService_ListExecutions_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Empty, CommandLog]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CommandService_ListExecutionsClient = grpc.ServerStreamingClient[CommandLog]

func (c *commandServiceClient) Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteResponse)
	err := c.cc.Invoke(ctx, CommandService_Execute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Cancel(ctx context.Context, in *CancelRequest, opts ...grpc.CallOption) (*CancelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelResponse)
	err := c.cc.Invoke(ctx, CommandService_Cancel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Retry(ctx context.Context, in *RetryRequest, opts ...grpc.CallOption) (*ExecuteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteResponse)
	err := c.cc.Invoke(ctx, CommandService_Retry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) DryRun(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*DryRunResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DryRunResult)
	err := c.cc.Invoke(ctx, CommandService_DryRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) UpdateExecutionStatus(ctx context.Context, in *UpdateExecutionStatusRequest, opts ...grpc.CallOption) (*UpdateExecutionStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateExecutionStatusResponse)
	err := c.cc.Invoke(ctx, CommandService_UpdateExecutionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) SubscribeLogs(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SubscribeRequest, CommandLog], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CommandService_ServiceDesc.Streams[1], CommandService_SubscribeLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, CommandLog]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CommandService_SubscribeLogsClient = grpc.BidiStreamingClient[SubscribeRequest, CommandLog]

func (c *commandServiceClient) SubscribeCommandEvents(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[CommandLog, CommandEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CommandService_ServiceDesc.Streams[2], CommandService_SubscribeCommandEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CommandLog, CommandEvent]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CommandService_SubscribeCommandEventsClient = grpc.BidiStreamingClient[CommandLog, CommandEvent]

func (c *commandServiceClient) AddMutualContact(ctx context.Context, in *Contact, opts ...grpc.CallOption) (*Contact, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Contact)
	err := c.cc.Invoke(ctx, CommandService_AddMutualContact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) RemoveMutualContact(ctx context.Context, in *Contact, opts ...grpc.CallOption) (*Contact, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Contact)
	err := c.cc.Invoke(ctx, CommandService_RemoveMutualContact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) ShowMyContact(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Contact, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Contact)
	err := c.cc.Invoke(ctx, CommandService_ShowMyContact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommandServiceServer is the server API for CommandService service.
// All implementations must embed UnimplementedCommandServiceServer
// for forward compatibility.
//
// CommandService provides all command and group management operations.
type CommandServiceServer interface {
	// Group management
	ListGroups(context.Context, *Empty) (*GroupsResponse, error)
	AddGroup(context.Context, *Group) (*Group, error)
	DeleteGroup(context.Context, *GroupRequest) (*Group, error)
	AddUserToGroup(context.Context, *UserGroupRequest) (*UserGroupResponse, error)
	RemoveUserFromGroup(context.Context, *UserGroupRequest) (*UserGroupResponse, error)
	// Template management
	ListCommands(context.Context, *CommandRequest) (*CommandsResponse, error)
	AddCommand(context.Context, *AddCommandRequest) (*Command, error)
	DeleteCommand(context.Context, *CommandRequest) (*Command, error)
	AddCommandToGroup(context.Context, *UserGroupRequest) (*UserGroupResponse, error)
	DeleteCommandFromGroup(context.Context, *UserGroupRequest) (*UserGroupResponse, error)
	// Execution
	ListExecutions(*Empty, grpc.ServerStreamingServer[CommandLog]) error
	Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error)
	Cancel(context.Context, *CancelRequest) (*CancelResponse, error)
	Retry(context.Context, *RetryRequest) (*ExecuteResponse, error)
	DryRun(context.Context, *ExecuteRequest) (*DryRunResult, error)
	// Update execution status
	UpdateExecutionStatus(context.Context, *UpdateExecutionStatusRequest) (*UpdateExecutionStatusResponse, error)
	// Streaming logs
	SubscribeLogs(grpc.BidiStreamingServer[SubscribeRequest, CommandLog]) error
	// Event listener for executors
	SubscribeCommandEvents(grpc.BidiStreamingServer[CommandLog, CommandEvent]) error
	// Add a contact for a user.
	AddMutualContact(context.Context, *Contact) (*Contact, error)
	RemoveMutualContact(context.Context, *Contact) (*Contact, error)
	ShowMyContact(context.Context, *Empty) (*Contact, error)
	mustEmbedUnimplementedCommandServiceServer()
}

// UnimplementedCommandServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCommandServiceServer struct{}

func (UnimplementedCommandServiceServer) ListGroups(context.Context, *Empty) (*GroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroups not implemented")
}
func (UnimplementedCommandServiceServer) AddGroup(context.Context, *Group) (*Group, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGroup not implemented")
}
func (UnimplementedCommandServiceServer) DeleteGroup(context.Context, *GroupRequest) (*Group, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroup not implemented")
}
func (UnimplementedCommandServiceServer) AddUserToGroup(context.Context, *UserGroupRequest) (*UserGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserToGroup not implemented")
}
func (UnimplementedCommandServiceServer) RemoveUserFromGroup(context.Context, *UserGroupRequest) (*UserGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUserFromGroup not implemented")
}
func (UnimplementedCommandServiceServer) ListCommands(context.Context, *CommandRequest) (*CommandsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCommands not implemented")
}
func (UnimplementedCommandServiceServer) AddCommand(context.Context, *AddCommandRequest) (*Command, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCommand not implemented")
}
func (UnimplementedCommandServiceServer) DeleteCommand(context.Context, *CommandRequest) (*Command, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCommand not implemented")
}
func (UnimplementedCommandServiceServer) AddCommandToGroup(context.Context, *UserGroupRequest) (*UserGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCommandToGroup not implemented")
}
func (UnimplementedCommandServiceServer) DeleteCommandFromGroup(context.Context, *UserGroupRequest) (*UserGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCommandFromGroup not implemented")
}
func (UnimplementedCommandServiceServer) ListExecutions(*Empty, grpc.ServerStreamingServer[CommandLog]) error {
	return status.Errorf(codes.Unimplemented, "method ListExecutions not implemented")
}
func (UnimplementedCommandServiceServer) Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedCommandServiceServer) Cancel(context.Context, *CancelRequest) (*CancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}
func (UnimplementedCommandServiceServer) Retry(context.Context, *RetryRequest) (*ExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retry not implemented")
}
func (UnimplementedCommandServiceServer) DryRun(context.Context, *ExecuteRequest) (*DryRunResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DryRun not implemented")
}
func (UnimplementedCommandServiceServer) UpdateExecutionStatus(context.Context, *UpdateExecutionStatusRequest) (*UpdateExecutionStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExecutionStatus not implemented")
}
func (UnimplementedCommandServiceServer) SubscribeLogs(grpc.BidiStreamingServer[SubscribeRequest, CommandLog]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeLogs not implemented")
}
func (UnimplementedCommandServiceServer) SubscribeCommandEvents(grpc.BidiStreamingServer[CommandLog, CommandEvent]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeCommandEvents not implemented")
}
func (UnimplementedCommandServiceServer) AddMutualContact(context.Context, *Contact) (*Contact, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMutualContact not implemented")
}
func (UnimplementedCommandServiceServer) RemoveMutualContact(context.Context, *Contact) (*Contact, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveMutualContact not implemented")
}
func (UnimplementedCommandServiceServer) ShowMyContact(context.Context, *Empty) (*Contact, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowMyContact not implemented")
}
func (UnimplementedCommandServiceServer) mustEmbedUnimplementedCommandServiceServer() {}
func (UnimplementedCommandServiceServer) testEmbeddedByValue()                        {}

// UnsafeCommandServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommandServiceServer will
// result in compilation errors.
type UnsafeCommandServiceServer interface {
	mustEmbedUnimplementedCommandServiceServer()
}

func RegisterCommandServiceServer(s grpc.ServiceRegistrar, srv CommandServiceServer) {
	// If the following call pancis, it indicates UnimplementedCommandServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CommandService_ServiceDesc, srv)
}

func _CommandService_ListGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).ListGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_ListGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).ListGroups(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_AddGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Group)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).AddGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_AddGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).AddGroup(ctx, req.(*Group))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_DeleteGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).DeleteGroup(ctx, req.(*GroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_AddUserToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).AddUserToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_AddUserToGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).AddUserToGroup(ctx, req.(*UserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_RemoveUserFromGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).RemoveUserFromGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_RemoveUserFromGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).RemoveUserFromGroup(ctx, req.(*UserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_ListCommands_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).ListCommands(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_ListCommands_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).ListCommands(ctx, req.(*CommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_AddCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).AddCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_AddCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).AddCommand(ctx, req.(*AddCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_DeleteCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).DeleteCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_DeleteCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).DeleteCommand(ctx, req.(*CommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_AddCommandToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).AddCommandToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_AddCommandToGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).AddCommandToGroup(ctx, req.(*UserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_DeleteCommandFromGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).DeleteCommandFromGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_DeleteCommandFromGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).DeleteCommandFromGroup(ctx, req.(*UserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_ListExecutions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CommandServiceServer).ListExecutions(m, &grpc.GenericServerStream[Empty, CommandLog]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CommandService_ListExecutionsServer = grpc.ServerStreamingServer[CommandLog]

func _CommandService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_Execute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Execute(ctx, req.(*ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_Cancel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Cancel(ctx, req.(*CancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Retry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Retry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_Retry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Retry(ctx, req.(*RetryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_DryRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).DryRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_DryRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).DryRun(ctx, req.(*ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_UpdateExecutionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExecutionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).UpdateExecutionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_UpdateExecutionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).UpdateExecutionStatus(ctx, req.(*UpdateExecutionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_SubscribeLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CommandServiceServer).SubscribeLogs(&grpc.GenericServerStream[SubscribeRequest, CommandLog]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CommandService_SubscribeLogsServer = grpc.BidiStreamingServer[SubscribeRequest, CommandLog]

func _CommandService_SubscribeCommandEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CommandServiceServer).SubscribeCommandEvents(&grpc.GenericServerStream[CommandLog, CommandEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CommandService_SubscribeCommandEventsServer = grpc.BidiStreamingServer[CommandLog, CommandEvent]

func _CommandService_AddMutualContact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Contact)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).AddMutualContact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_AddMutualContact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).AddMutualContact(ctx, req.(*Contact))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_RemoveMutualContact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Contact)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).RemoveMutualContact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_RemoveMutualContact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).RemoveMutualContact(ctx, req.(*Contact))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_ShowMyContact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).ShowMyContact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_ShowMyContact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).ShowMyContact(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CommandService_ServiceDesc is the grpc.ServiceDesc for CommandService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommandService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cmd.CommandService",
	HandlerType: (*CommandServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListGroups",
			Handler:    _CommandService_ListGroups_Handler,
		},
		{
			MethodName: "AddGroup",
			Handler:    _CommandService_AddGroup_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _CommandService_DeleteGroup_Handler,
		},
		{
			MethodName: "AddUserToGroup",
			Handler:    _CommandService_AddUserToGroup_Handler,
		},
		{
			MethodName: "RemoveUserFromGroup",
			Handler:    _CommandService_RemoveUserFromGroup_Handler,
		},
		{
			MethodName: "ListCommands",
			Handler:    _CommandService_ListCommands_Handler,
		},
		{
			MethodName: "AddCommand",
			Handler:    _CommandService_AddCommand_Handler,
		},
		{
			MethodName: "DeleteCommand",
			Handler:    _CommandService_DeleteCommand_Handler,
		},
		{
			MethodName: "AddCommandToGroup",
			Handler:    _CommandService_AddCommandToGroup_Handler,
		},
		{
			MethodName: "DeleteCommandFromGroup",
			Handler:    _CommandService_DeleteCommandFromGroup_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _CommandService_Execute_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _CommandService_Cancel_Handler,
		},
		{
			MethodName: "Retry",
			Handler:    _CommandService_Retry_Handler,
		},
		{
			MethodName: "DryRun",
			Handler:    _CommandService_DryRun_Handler,
		},
		{
			MethodName: "UpdateExecutionStatus",
			Handler:    _CommandService_UpdateExecutionStatus_Handler,
		},
		{
			MethodName: "AddMutualContact",
			Handler:    _CommandService_AddMutualContact_Handler,
		},
		{
			MethodName: "RemoveMutualContact",
			Handler:    _CommandService_RemoveMutualContact_Handler,
		},
		{
			MethodName: "ShowMyContact",
			Handler:    _CommandService_ShowMyContact_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListExecutions",
			Handler:       _CommandService_ListExecutions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeLogs",
			Handler:       _CommandService_SubscribeLogs_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeCommandEvents",
			Handler:       _CommandService_SubscribeCommandEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/cmd/cmd.proto",
}
