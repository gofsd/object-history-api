// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.6
// source: proto/cmd/cmd.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CommandService_CreateGroup_FullMethodName           = "/command.CommandService/CreateGroup"
	CommandService_DeleteGroup_FullMethodName           = "/command.CommandService/DeleteGroup"
	CommandService_AddUserToGroup_FullMethodName        = "/command.CommandService/AddUserToGroup"
	CommandService_RemoveUserFromGroup_FullMethodName   = "/command.CommandService/RemoveUserFromGroup"
	CommandService_AddCommandTemplate_FullMethodName    = "/command.CommandService/AddCommandTemplate"
	CommandService_DeleteCommandTemplate_FullMethodName = "/command.CommandService/DeleteCommandTemplate"
	CommandService_Execute_FullMethodName               = "/command.CommandService/Execute"
	CommandService_Cancel_FullMethodName                = "/command.CommandService/Cancel"
	CommandService_Retry_FullMethodName                 = "/command.CommandService/Retry"
	CommandService_DryRun_FullMethodName                = "/command.CommandService/DryRun"
	CommandService_SubscribeLogs_FullMethodName         = "/command.CommandService/SubscribeLogs"
)

// CommandServiceClient is the client API for CommandService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommandServiceClient interface {
	// Group management
	CreateGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Group, error)
	DeleteGroup(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*Group, error)
	AddUserToGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupRequest, error)
	RemoveUserFromGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupRequest, error)
	// Template management
	AddCommandTemplate(ctx context.Context, in *AddCommandTemplateRequest, opts ...grpc.CallOption) (*CommandTemplate, error)
	DeleteCommandTemplate(ctx context.Context, in *DeleteCommandTemplateRequest, opts ...grpc.CallOption) (*CommandTemplate, error)
	// Execution
	Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error)
	Cancel(ctx context.Context, in *CancelRequest, opts ...grpc.CallOption) (*CancelResponse, error)
	Retry(ctx context.Context, in *RetryRequest, opts ...grpc.CallOption) (*ExecuteResponse, error)
	DryRun(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*DryRunResult, error)
	// Streaming logs
	SubscribeLogs(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CommandLog], error)
}

type commandServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommandServiceClient(cc grpc.ClientConnInterface) CommandServiceClient {
	return &commandServiceClient{cc}
}

func (c *commandServiceClient) CreateGroup(ctx context.Context, in *Group, opts ...grpc.CallOption) (*Group, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Group)
	err := c.cc.Invoke(ctx, CommandService_CreateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) DeleteGroup(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*Group, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Group)
	err := c.cc.Invoke(ctx, CommandService_DeleteGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) AddUserToGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserGroupRequest)
	err := c.cc.Invoke(ctx, CommandService_AddUserToGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) RemoveUserFromGroup(ctx context.Context, in *UserGroupRequest, opts ...grpc.CallOption) (*UserGroupRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserGroupRequest)
	err := c.cc.Invoke(ctx, CommandService_RemoveUserFromGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) AddCommandTemplate(ctx context.Context, in *AddCommandTemplateRequest, opts ...grpc.CallOption) (*CommandTemplate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandTemplate)
	err := c.cc.Invoke(ctx, CommandService_AddCommandTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) DeleteCommandTemplate(ctx context.Context, in *DeleteCommandTemplateRequest, opts ...grpc.CallOption) (*CommandTemplate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandTemplate)
	err := c.cc.Invoke(ctx, CommandService_DeleteCommandTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteResponse)
	err := c.cc.Invoke(ctx, CommandService_Execute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Cancel(ctx context.Context, in *CancelRequest, opts ...grpc.CallOption) (*CancelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelResponse)
	err := c.cc.Invoke(ctx, CommandService_Cancel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) Retry(ctx context.Context, in *RetryRequest, opts ...grpc.CallOption) (*ExecuteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteResponse)
	err := c.cc.Invoke(ctx, CommandService_Retry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) DryRun(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*DryRunResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DryRunResult)
	err := c.cc.Invoke(ctx, CommandService_DryRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandServiceClient) SubscribeLogs(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CommandLog], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CommandService_ServiceDesc.Streams[0], CommandService_SubscribeLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, CommandLog]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CommandService_SubscribeLogsClient = grpc.ServerStreamingClient[CommandLog]

// CommandServiceServer is the server API for CommandService service.
// All implementations must embed UnimplementedCommandServiceServer
// for forward compatibility.
type CommandServiceServer interface {
	// Group management
	CreateGroup(context.Context, *Group) (*Group, error)
	DeleteGroup(context.Context, *GroupRequest) (*Group, error)
	AddUserToGroup(context.Context, *UserGroupRequest) (*UserGroupRequest, error)
	RemoveUserFromGroup(context.Context, *UserGroupRequest) (*UserGroupRequest, error)
	// Template management
	AddCommandTemplate(context.Context, *AddCommandTemplateRequest) (*CommandTemplate, error)
	DeleteCommandTemplate(context.Context, *DeleteCommandTemplateRequest) (*CommandTemplate, error)
	// Execution
	Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error)
	Cancel(context.Context, *CancelRequest) (*CancelResponse, error)
	Retry(context.Context, *RetryRequest) (*ExecuteResponse, error)
	DryRun(context.Context, *ExecuteRequest) (*DryRunResult, error)
	// Streaming logs
	SubscribeLogs(*SubscribeRequest, grpc.ServerStreamingServer[CommandLog]) error
	mustEmbedUnimplementedCommandServiceServer()
}

// UnimplementedCommandServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCommandServiceServer struct{}

func (UnimplementedCommandServiceServer) CreateGroup(context.Context, *Group) (*Group, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGroup not implemented")
}
func (UnimplementedCommandServiceServer) DeleteGroup(context.Context, *GroupRequest) (*Group, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroup not implemented")
}
func (UnimplementedCommandServiceServer) AddUserToGroup(context.Context, *UserGroupRequest) (*UserGroupRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserToGroup not implemented")
}
func (UnimplementedCommandServiceServer) RemoveUserFromGroup(context.Context, *UserGroupRequest) (*UserGroupRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUserFromGroup not implemented")
}
func (UnimplementedCommandServiceServer) AddCommandTemplate(context.Context, *AddCommandTemplateRequest) (*CommandTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCommandTemplate not implemented")
}
func (UnimplementedCommandServiceServer) DeleteCommandTemplate(context.Context, *DeleteCommandTemplateRequest) (*CommandTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCommandTemplate not implemented")
}
func (UnimplementedCommandServiceServer) Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedCommandServiceServer) Cancel(context.Context, *CancelRequest) (*CancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}
func (UnimplementedCommandServiceServer) Retry(context.Context, *RetryRequest) (*ExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retry not implemented")
}
func (UnimplementedCommandServiceServer) DryRun(context.Context, *ExecuteRequest) (*DryRunResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DryRun not implemented")
}
func (UnimplementedCommandServiceServer) SubscribeLogs(*SubscribeRequest, grpc.ServerStreamingServer[CommandLog]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeLogs not implemented")
}
func (UnimplementedCommandServiceServer) mustEmbedUnimplementedCommandServiceServer() {}
func (UnimplementedCommandServiceServer) testEmbeddedByValue()                        {}

// UnsafeCommandServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommandServiceServer will
// result in compilation errors.
type UnsafeCommandServiceServer interface {
	mustEmbedUnimplementedCommandServiceServer()
}

func RegisterCommandServiceServer(s grpc.ServiceRegistrar, srv CommandServiceServer) {
	// If the following call pancis, it indicates UnimplementedCommandServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CommandService_ServiceDesc, srv)
}

func _CommandService_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Group)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_CreateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).CreateGroup(ctx, req.(*Group))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_DeleteGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).DeleteGroup(ctx, req.(*GroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_AddUserToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).AddUserToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_AddUserToGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).AddUserToGroup(ctx, req.(*UserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_RemoveUserFromGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).RemoveUserFromGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_RemoveUserFromGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).RemoveUserFromGroup(ctx, req.(*UserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_AddCommandTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCommandTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).AddCommandTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_AddCommandTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).AddCommandTemplate(ctx, req.(*AddCommandTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_DeleteCommandTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCommandTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).DeleteCommandTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_DeleteCommandTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).DeleteCommandTemplate(ctx, req.(*DeleteCommandTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_Execute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Execute(ctx, req.(*ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_Cancel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Cancel(ctx, req.(*CancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_Retry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Retry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_Retry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Retry(ctx, req.(*RetryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_DryRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).DryRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommandService_DryRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).DryRun(ctx, req.(*ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandService_SubscribeLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CommandServiceServer).SubscribeLogs(m, &grpc.GenericServerStream[SubscribeRequest, CommandLog]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CommandService_SubscribeLogsServer = grpc.ServerStreamingServer[CommandLog]

// CommandService_ServiceDesc is the grpc.ServiceDesc for CommandService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommandService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "command.CommandService",
	HandlerType: (*CommandServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateGroup",
			Handler:    _CommandService_CreateGroup_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _CommandService_DeleteGroup_Handler,
		},
		{
			MethodName: "AddUserToGroup",
			Handler:    _CommandService_AddUserToGroup_Handler,
		},
		{
			MethodName: "RemoveUserFromGroup",
			Handler:    _CommandService_RemoveUserFromGroup_Handler,
		},
		{
			MethodName: "AddCommandTemplate",
			Handler:    _CommandService_AddCommandTemplate_Handler,
		},
		{
			MethodName: "DeleteCommandTemplate",
			Handler:    _CommandService_DeleteCommandTemplate_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _CommandService_Execute_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _CommandService_Cancel_Handler,
		},
		{
			MethodName: "Retry",
			Handler:    _CommandService_Retry_Handler,
		},
		{
			MethodName: "DryRun",
			Handler:    _CommandService_DryRun_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeLogs",
			Handler:       _CommandService_SubscribeLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/cmd/cmd.proto",
}
